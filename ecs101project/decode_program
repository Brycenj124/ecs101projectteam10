# Decoder.py
# ECS101
from pathlib import Path
import pandas as pd

dir = Path(__file__).resolve().parent
COMPRESSION_PATH = dir / "compression_table.xlsx"


def bits_only(s: str):
    """keep only 0 and 1 from any input string."""
    return "".join(ch for ch in s if ch in "01")


def take_next_code(bits: str, codes: set[str], min_len: int, max_len: int):
    for length in range(min_len, max_len + 1):  # try lengths from min to max
        code = bits[:length]
        if code in codes:
            return code, bits[length:]
    raise ValueError("no valid code found")


def load_compression(path: str):
    df = pd.read_excel(path)

    code_to_char = {
        str(row["Binary Code"]).strip(): str(row["Character"])
        for _, row in df.iterrows()
        if pd.notna(row.get("Character")) and pd.notna(row.get("Binary Code"))
    }

    if not code_to_char:
        raise ValueError("missing or empty codebook")

    lengths = [len(code) for code in code_to_char.keys()]
    return code_to_char, min(lengths), max(lengths)


def decoder(input: str = dir / "BinOutput.txt",
            output: str = dir / "TextOutput.txt",
            compression_path: str = COMPRESSION_PATH):

    code_to_char, min_len, max_len = load_compression(compression_path)
    codes = set(code_to_char.keys())

    # read encoded file
    with open(input, "r", encoding="utf-8") as f:
        raw = f.read().strip()

    # remove prefix (everything before and including first ".")
    if "." in raw:
        _, bitstream = raw.split(".", 1)
    else:
        bitstream = raw

    # keep only valid bits
    bits = bits_only(bitstream)

    decoded = []
    while bits:
        code, bits = take_next_code(bits, codes, min_len, max_len)
        decoded.append(code_to_char[code])

    with open(output, "w", encoding="utf-8") as f:
        f.write("".join(decoded))

    print(f"Decoded text saved to {output}")


if __name__ == "__main__":
    decoder()
